"use strict";

import { Select } from "ol/interaction";
import Style from "ol/style/Style";
import Fill from "ol/style/Fill";
import Stroke from "ol/style/Stroke";
import Text from "ol/style/Text";
import {pointerMove, click, singleClick, never} from "ol/events/condition";

/**
 * Hover functions
 */

 export function hover(map) {
     let layers = map.getLayers().getArray().filter(layer => {
         return layer.get("name") === "vulnerability_ribbon";
     });
     let hover = new Select({
         condition: pointerMove,
        //  style: (feature, resolution) => {
        //     if (feature.get("selected") === true) {
        //         return new Style();
        //     } else {
        //         return [
        //             new Style({
        //                 fill: new Fill({
        //                     color: 'rgba(255,255,255,0.4)',
        //                 }),
        //                 stroke: new Stroke({
        //                     color: "white",
        //                     width: 5
        //                 })
        //             }),
        //             new Style({
        //                 stroke: new Stroke({
        //                     color: "#3399CC",
        //                     width: 3
        //                 })
        //             })
        //         ];
        //     }
        //  },
         layers: layers
     });
     hover.set("name", "hover_vulnerability_ribbon");
     _onHover(hover);
     return hover;
 }

 function _onHover(hover) {
    hover.on("select", _hovered);
 }

 function _hovered(evt) {
    // turn on select vuln ribbon interaction
    let interactions = evt.target.getMap().getInteractions();
    interactions.forEach(interaction => {
        let name = interaction.get("name");
        if (!name) return;
        if (name === "select_vulnerability_ribbon") {
            interaction.setActive(true);
        } else if (name.includes("select_")) {
            interaction.setActive(false);
        }
    });

    // set cursor style 
    let target = evt.target.getMap().getTarget();
    let node = document.getElementById(target);
    if (!node) return;
    if (evt.selected.length > 0) {
        node.style.cursor = "pointer";
    } else {
        node.style.cursor = "";
    }
 }

 /**
  * Select functions
  */

export function select(map) {
    let layers = map.getLayers().getArray().filter(layer => {
        return layer.get("name") === "vulnerability_ribbon";
    });
    let select = new Select({
        addCondition: singleClick,
        removeCondition: never,
        //style: new Style(),
        layers: layers
    });
    select.set("name", "select_vulnerability_ribbon");
    select.setActive(false);
    _onSingleClick(select);
    return select;
}

function _onSingleClick(select) {
    select.on("select", _clicked);
}


import GeoJSON from "ol/format/GeoJSON";
import bearing from "@turf/bearing";
import {toMercator, toWgs84} from "@turf/projection";
import along from "@turf/along";
import lineArc from "@turf/line-arc";
import {polygon} from "@turf/helpers";

const geojsonformat = new GeoJSON();

function _clicked(evt) {
    if (evt.selected.length === 0) return;
    
    let selected = [];
    if (evt.target.getFeatures().getLength() <= 1) {
        selected = makeInitialSelection(evt);
    } else {
        selected = makeAdjacentSelection(evt);
    }

    if (!selected || selected.length === 0) return;

    let converted = selected.map(feature => {
        let f = geojsonformat.writeFeatureObject(feature);
        return toWgs84(f);
    });

    let fc = featureCollection(converted);
    let allSegments = lineSegment(fc);

    let layer = evt.target.getMap().getLayers().getArray().filter(l => {
        return l.get('name') === 'vulnerability_ribbon';
    })[0];
    let offset = layer.get('offset_geojson');
    offset = toWgs84(offset);

    let arcs = allSegments.features.forEach(segment => {
        let arc = createArcForSegment(segment, offset);
        let arcFeature = geojsonformat.readFeatureFromObject(arc);
        evt.target.dispatchEvent({
            "type": "update_impact_zone",
            "arc": arcFeature
        });
    });

    return arcs;
}

import {lineString} from "@turf/helpers";
import lineIntersect from "@turf/line-intersect";
import distance from "@turf/distance";


function createArcForSegment(segment, offset) {
    let brng = calcSegmentBearing(segment.geometry);

    let mid = along(segment, 0.01524, { units: "kilometers"});

    let {minOffset, maxOffset} = calcArcBearingsFromSegmentBearing(brng);

    let arc = lineArc(mid.geometry, 0.1524, minOffset, maxOffset, { steps: 180 });

    let newArc = arc.geometry.coordinates.map(c => {
        let tracer = lineString([c, mid.geometry.coordinates]);
        let intersections = lineIntersect(tracer, offset);
        let len = intersections.features.length;
        if (intersections && intersections.features.length > 0) {
            let withDistance = intersections.features.map(f => {
                return {
                    "feature": f,
                    "distance": distance(f, mid)
                };
            });
            let closestIntersection = withDistance.reduce((closest, next) => {
                if (next.distance < closest.distance) {
                    return next;
                } else {
                    return closest;
                }
            });
            return closestIntersection.feature.geometry.coordinates;
        } else {
            return c;
        }
    });

    let poly = polygon([
        segment.geometry.coordinates
        .concat(newArc)
        .concat([segment.geometry.coordinates[0]])
    ]);

    return toMercator(poly);
}


function calcSegmentBearing(point) {
    let start = point.coordinates[0];
    let end = point.coordinates[point.coordinates.length - 1];
    let brng = bearing(start, end);
    return brng;
}

function calcArcBearingsFromSegmentBearing(brng) {
    let midBrng = null,
        minOffset = null,
        maxOffset = null;
    if (brng > 90) {
        midBrng = brng - 270;
    } else {
        midBrng = brng + 90;
    }

    minOffset = midBrng - 10;
    if (minOffset < -180) {
        minOffset = minOffset + 360;
    }

    maxOffset = midBrng + 10;
    if (maxOffset > 180) {
        maxOffset = maxOffset - 360;
    }

    return {
        minOffset: minOffset,
        maxOffset: maxOffset
    };
}

import length from "@turf/length";
import lineSegment from "@turf/line-segment";
import {featureCollection} from "@turf/helpers";
import {compareFeaturesById} from "../misc.js";

/**
 * Make the first selection on the vulnerability ribbon.
 * 
 * In addition to the feature actually selected, this will
 * add two features to the left and two features to the right
 * for a total of 5 segments selected.
 * 
 * @param {SelectEvent} evt 
 */
function makeInitialSelection(evt) {
    // get selected segment
    let selection = evt.selected[0];
    // flag as selected (for hover stylinz)
    selection.set("selected", true);
    // get selected segment id
    let selectedId = selection.get("id");
    // create list of other segment ids to possibly select
    let idsToSelect = [ selectedId - 2, selectedId - 1, selectedId + 1, selectedId + 2 ];
    // set upper/lower id constraints for where to check for subsequent selections.
    evt.target.set("lower_id", idsToSelect[0] - 1);
    evt.target.set("upper_id", idsToSelect[3] + 1);
    // get additional features to actually select
    let toSelect = findFeaturesToAdd(evt, idsToSelect);
    addToSelect(evt, toSelect);

    // add original selection to get complete list of selected items for return
    toSelect.push(selection);
    // sort by id
    toSelect.sort(compareFeaturesById);

    return toSelect;

}



/**
 * Make another selection beyond the first. 
 *
 * In other words, once a selection has been made, you are able to add another
 * 5-segment selection only if it is adjacent (left or right) to the main selection
 *    
 * So if first selection is feature ids [10, 11, 12, 13, 14] then you'll next be
 * able to click a feature from [5, 6, 7, 8, 9] or [15, 16, 17, 18, 19] and have
 * that group be added to the selection. Features outside that range are ignored.
 *
 * Each 5-segment selection that is added to the main selection will update the 
 * constraints to be used in the following clicks
 * 
 * @param {SelectEvent} evt 
 */
function makeAdjacentSelection(evt) {
    // get lower and upper bounds and new ranges
    let lowerId = evt.target.get("lower_id");
    let lowerRange = [lowerId - 4, lowerId - 3, lowerId - 2, lowerId - 1, lowerId];
    let upperId = evt.target.get("upper_id");
    let upperRange = [upperId, upperId + 1, upperId + 2, upperId + 3, upperId + 4];
    // get selected segment
    let selection = evt.selected[0];
    // get selected segment id
    let selectionId = selection.get("id");
    
    let idsToSelect = [];
    if (lowerRange.includes(selectionId)) {
        idsToSelect = lowerRange.filter(id => {
            return id !== selectionId;
        });
        evt.target.set("lower_id", lowerRange[0] - 1);
    } else if (upperRange.includes(selectionId)) {
        idsToSelect = upperRange.filter(id => {
            return id !== selectionId;
        });
        evt.target.set("upper_id", upperRange[4] + 1);
    } else {
         evt.target.getFeatures().remove(selection);
         return;
    }
    // flag as selected (for hover stylinz)
    selection.set("selected", true);

    let toSelect = findFeaturesToAdd(evt, idsToSelect);
    addToSelect(evt, toSelect);

    // add original selection to get complete list of selected items for return
    toSelect.push(selection);
    // sort by id
    toSelect.sort(compareFeaturesById);

    return toSelect;
}

function findFeaturesToAdd(evt, ids) {
    // get ribbon layer
    let ribbon = evt.target.getMap().getLayers().getArray().filter(layer => {
        return layer.get("name") === "vulnerability_ribbon";
    })[0];
    // filter features to match those we are looking for
    let toSelect = ribbon.getSource().getFeatures().filter(feature => {
        return ids.includes(feature.get("id"));
    });
    return toSelect;
    // add new selections to select interaction
    let collection = evt.target.getFeatures();
    toSelect.forEach(feature => {
        collection.push(feature);
    });
}

function addToSelect(evt, featuresToSelect) {
    let collection = evt.target.getFeatures();
    featuresToSelect.forEach(feature => {
        // flag as selected (for hover stylinz)
        feature.set("selected", true);
        // add to selected collection
        collection.push(feature);
    });
}
