"use strict";

import { Select } from "ol/interaction";
import Style from "ol/style/Style";
import Fill from "ol/style/Fill";
import Stroke from "ol/style/Stroke";
import Text from "ol/style/Text";
import {pointerMove, click, singleClick, never} from "ol/events/condition";

/**
 * Hover functions
 */

 export function hover(map) {
     let layers = map.getLayers().getArray().filter(layer => {
         return layer.get("name") === "vulnerability_ribbon";
     });
     let hover = new Select({
         condition: pointerMove,
         style: (feature, resolution) => {
            if (feature.get("selected") === true) {
                return new Style();
            } else {
                return [
                    new Style({
                        fill: new Fill({
                            color: 'rgba(255,255,255,0.4)',
                        }),
                        stroke: new Stroke({
                            color: "white",
                            width: 5
                        })
                    }),
                    new Style({
                        stroke: new Stroke({
                            color: "#3399CC",
                            width: 3
                        })
                    })
                ];
            }
         },
         layers: layers
     });
     hover.set("name", "hover_vulnerability_ribbon");
     _onHover(hover);
     return hover;
 }

 function _onHover(hover) {
    hover.on("select", _hovered);
 }

 function _hovered(evt) {
    // turn on select vuln ribbon interaction
    let interactions = evt.target.getMap().getInteractions();
    interactions.forEach(interaction => {
        let name = interaction.get("name");
        if (!name) return;
        if (name === "select_vulnerability_ribbon") {
            interaction.setActive(true);
        } else if (name.includes("select_")) {
            interaction.setActive(false);
        }
    });

    // set cursor style 
    let target = evt.target.getMap().getTarget();
    let node = document.getElementById(target);
    if (!node) return;
    if (evt.selected.length > 0) {
        node.style.cursor = "pointer";
    } else {
        node.style.cursor = "";
    }
 }

 /**
  * Select functions
  */

export function select(map) {
    let layers = map.getLayers().getArray().filter(layer => {
        return layer.get("name") === "vulnerability_ribbon";
    });
    let select = new Select({
        addCondition: singleClick,
        removeCondition: never,
        style: new Style(),
        layers: layers
    });
    select.set("name", "select_vulnerability_ribbon");
    select.setActive(false);
    _onSingleClick(select);
    return select;
}

function _onSingleClick(select) {
    select.on("select", _clicked);
}

function _clicked(evt) {
    if (evt.selected.length === 0) return;

    if (evt.target.getFeatures().getLength() <= 1) {
        makeInitialSelection(evt);
    } else {
        makeAdjacentSelection(evt);
    }
}

/**
 * Make the first selection on the vulnerability ribbon.
 * 
 * In addition to the feature actually selected, this will
 * add two features to the left and two features to the right
 * for a total of 5 segments selected.
 * 
 * @param {SelectEvent} evt 
 */
function makeInitialSelection(evt) {
    // get selected segment
    let selection = evt.selected[0];
    // flag as selected (for hover stylinz)
    selection.set("selected", true);
    // get selected segment id
    let selectedId = selection.get("OBJECTID");
    // create list of other segment ids to possibly select
    let idsToSelect = [ selectedId - 2, selectedId - 1, selectedId + 1, selectedId + 2 ];
    // set upper/lower id constraints for where to check for subsequent selections.
    evt.target.set("lower_id", idsToSelect[0] - 1);
    evt.target.set("upper_id", idsToSelect[3] + 1);
    let toSelect = findFeaturesToAdd(evt, idsToSelect);
    addToSelect(evt, toSelect);
    evt.target.dispatchEvent("update_impact_zone");
}

/**
 * Make another selection beyond the first. 
 *
 * In other words, once a selection has been made, you are able to add another
 * 5-segment selection only if it is adjacent (left or right) to the main selection
 *    
 * So if first selection is feature ids [10, 11, 12, 13, 14] then you'll next be
 * able to click a feature from [5, 6, 7, 8, 9] or [15, 16, 17, 18, 19] and have
 * that group be added to the selection. Features outside that range are ignored.
 *
 * Each 5-segment selection that is added to the main selection will update the 
 * constraints to be used in the following clicks
 * 
 * @param {SelectEvent} evt 
 */
function makeAdjacentSelection(evt) {
    // get lower and upper bounds and new ranges
    let lowerId = evt.target.get("lower_id");
    let lowerRange = [lowerId - 4, lowerId - 3, lowerId - 2, lowerId - 1, lowerId];
    let upperId = evt.target.get("upper_id");
    let upperRange = [upperId, upperId + 1, upperId + 2, upperId + 3, upperId + 4];
    // get selected segment
    let selection = evt.selected[0];
    // get selected segment id
    let selectionId = selection.get("OBJECTID");
    
    let idsToSelect = [];
    if (lowerRange.includes(selectionId)) {
        idsToSelect = lowerRange.filter(id => {
            return id !== selectionId;
        });
        evt.target.set("lower_id", lowerRange[0] - 1);
    } else if (upperRange.includes(selectionId)) {
        idsToSelect = upperRange.filter(id => {
            return id !== selectionId;
        });
        evt.target.set("upper_id", upperRange[4] + 1);
    } else {
         evt.target.getFeatures().remove(selection);
         return;
    }
    // flag as selected (for hover stylinz)
    selection.set("selected", true);

    let toSelect = findFeaturesToAdd(evt, idsToSelect);
    addToSelect(evt, toSelect);
    evt.target.dispatchEvent("update_impact_zone");
}

function findFeaturesToAdd(evt, ids) {
    // get ribbon layer
    let ribbon = evt.target.getMap().getLayers().getArray().filter(layer => {
        return layer.get("name") === "vulnerability_ribbon";
    })[0];
    // filter features to match those we are looking for
    let toSelect = ribbon.getSource().getFeatures().filter(feature => {
        return ids.includes(feature.get("OBJECTID"));
    });
    return toSelect;
    // add new selections to select interaction
    let collection = evt.target.getFeatures();
    toSelect.forEach(feature => {
        collection.push(feature);
    });
}

function addToSelect(evt, featuresToSelect) {
    let collection = evt.target.getFeatures();
    featuresToSelect.forEach(feature => {
        // flag as selected (for hover stylinz)
        feature.set("selected", true);
        // add to selected collection
        collection.push(feature);
    });
}
