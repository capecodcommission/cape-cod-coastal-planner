"use strict";

import { Select } from "ol/interaction";
import Style from "ol/style/Style";
import Stroke from "ol/style/Stroke";
import {pointerMove, singleClick, never} from "ol/events/condition";
import GeoJSON from "ol/format/GeoJSON";
import bearing from "@turf/bearing";
import {toMercator, toWgs84} from "@turf/projection";
import {featureCollection} from "@turf/helpers";
import along from "@turf/along";
import lineArc from "@turf/line-arc";
import {polygon} from "@turf/helpers";
import buffer from "@turf/buffer";
import lineSplit from "@turf/line-split";
import lineSegment from "@turf/line-segment";
import union from "@turf/union";
import {lineString} from "@turf/helpers";
import lineIntersect from "@turf/line-intersect";
import distance from "@turf/distance";
import length from "@turf/length";
import {compareFeaturesById} from "../misc.js";

/**
 * Hover functions
 */

 export function hover(map) {
     let layers = map.getLayers().getArray().filter(layer => {
         return layer.get("name") === "vulnerability_ribbon";
     });
     let hover = new Select({
         condition: pointerMove,
         style: (feature, resolution) => {
            if (feature.get("selected") === true) {
                return new Style();
            } else {
                return [
                    new Style({
                        stroke: new Stroke({
                            color: "white",
                            width: 5
                        })
                    }),
                    new Style({
                        stroke: new Stroke({
                            color: "#3399CC",
                            width: 3
                        })
                    })
                ];
            }
         },
         hitTolerance: 6,
         layers: layers
     });
     hover.set("name", "hover_vulnerability_ribbon");
     _onHover(hover);
     return hover;
 }

 function _onHover(hover) {
    hover.on("select", _hovered);
 }

 function _hovered(evt) {
    // turn on select vuln ribbon interaction
    let interactions = evt.target.getMap().getInteractions();
    interactions.forEach(interaction => {
        let name = interaction.get("name");
        if (!name) return;
        if (name === "select_vulnerability_ribbon") {
            interaction.setActive(true);
        } else if (name.includes("select_")) {
            interaction.setActive(false);
        }
    });

    // set cursor style 
    let target = evt.target.getMap().getTarget();
    let node = document.getElementById(target);
    if (!node) return;
    if (evt.selected.length > 0) {
        node.style.cursor = "pointer";
    } else {
        node.style.cursor = "";
    }
 }

/**
 * Select functions
 */

export function select(map) {
    let layers = map.getLayers().getArray().filter(layer => {
        return layer.get("name") === "vulnerability_ribbon";
    });
    let select = new Select({
        addCondition: singleClick,
        removeCondition: never,
        style: new Style({
            stroke: new Stroke({
                color: "rgba(51,153,204,1)",
                width: 10
            })
        }),
        hitTolerance: 6,
        layers: layers
    });
    select.set("name", "select_vulnerability_ribbon");
    select.setActive(false);
    select.on("select", calculateZoneOfImpact);
    map.on("clear_zone_of_impact", () => {
        resetSelectVulnerabilityRibbon(select);
    });
    return select;
}

const geojsonformat = new GeoJSON();

// You can select a maximum of eight, consequent 500ft sections of ribbon. This 
// is sort of an arbitrary number mainly to prevent users from selecting
// the entire shoreline. Adjust if desired.
const MAX_RIBBON_SELECTIONS = 8;

/**
 * Calculates the zone of impact when a user selects a part of the vulnerability ribbon.
 * @param {SelectEvent} evt 
 */
function calculateZoneOfImpact(evt) {
    if (evt.selected.length === 0) return;
    
    // If no selections have been made yet, make an initial selection,
    // otherwise make an adjacent selection as long as its under MAX_RIBBON_SELECTIONS.
    let selected = [];
    let num_selected = evt.target.get("num_selected");    
    if (!Number.isInteger(num_selected)) {
        selected = makeInitialSelection(evt);
    } else if (num_selected < MAX_RIBBON_SELECTIONS) {
        selected = makeAdjacentSelection(evt);
    } else {
        evt.target.getFeatures().remove(evt.selected[0]);
        return;
    }

    if (!selected || selected.length === 0) return;

    // convert ALL selected features to GeoJSON and reproject to WGS84
    let all = geojsonformat.writeFeaturesObject(evt.target.getFeatures().getArray());
    all = toWgs84(all);

    // calculate whether this selection should allow strategies for each type: 
    // SaltMarsh, CoastalBank, Undeveloped
    //
    // a placement is valid if more than 50% of the selection carries Y values
    let placementTotals = all.features.reduce((acc, feat) => {
        if (feat && feat.properties && feat.properties.SaltMarsh === "Y") {
            acc["SaltMarsh"]++;
        }
        if (feat && feat.properties && feat.properties.CoastalBank === "Y") {
            acc["CoastalBank"]++;
        }
        if (feat && feat.properties && feat.properties.Undeveloped === "Y") {
            acc["Undeveloped"]++;
        }
        return acc;
    }, { "SaltMarsh": 0, "CoastalBank": 0, "Undeveloped": 0});
    console.log(`Num Segments: ${all.features.length}`);
    console.log(placementTotals);
    let placementsMajorities = {
        "majoritySaltMarsh": false,
        "majorityCoastalBank": false,
        "majorityUndeveloped": false
    }
    if (placementTotals["SaltMarsh"] / all.features.length >= 0.5) {
        placementsMajorities["majoritySaltMarsh"] = true;
    }
    if (placementTotals["CoastalBank"] / all.features.length >= 0.5) {
        placementsMajorities["majorityCoastalBank"] = true;
    }
    if (placementTotals["Undeveloped"] / all.features.length >= 0.5) {
        placementsMajorities["majorityUndeveloped"] = true;
    }
    console.log(placementsMajorities);
    console.log("------------------------");

    // calculate the total length
    let lengthAll = length(all, { units: 'miles' }) * 5280;

    // convert the most recently selected features to GeoJSON and reproject to WGS84
    let converted = selected.map(feature => {
        let f = geojsonformat.writeFeatureObject(feature);
        return toWgs84(f);
    });

    // bundle the array of features up into a FeatureCollection
    let fc = featureCollection(converted);    

    
    // Fetch the Vulnerability Ribbon layer and grab the `offset_geojson`.
    // The `offset_geojson` should already be reprojected to WGS84. It should
    // be a negative offset line from the true vulnerability ribbon 
    let layer = evt.target.getMap().getLayers().getArray().filter(l => {
        return l.get('name') === 'vulnerability_ribbon';
    })[0];
    let ribbonOffset = layer.get('offset_ribbon');

    // Create a 1000ft buffer for each of the segement features and union them; 1000ft
    // is large enough to encompase everything in the radius of arc sectors (500ft) plus
    // the max length of a selection (5 x 100ft segments = 500ft). 
    // NOTE: If either of those values grow, this 1000ft buffer will need to grow!
    //
    // This final shape will be used like a cookie-cutter (more or less) against the 
    // ribbon offset to drastically speed up the line intersection operations to be
    // performed against it later on.
    let impactAreaBuffer = buffer(fc, 0.3048); // 1000ft = 0.3048km
    impactAreaBuffer = union(...impactAreaBuffer.features);

    // Line Split will cut the ribbon offset up into intersecting segments based on
    // the impact area buffer. We remove the first and last segments, as those are the
    // pieces that likely contain the majority of ribbon vertices and are those that
    // have no chance of being in the zone of impact.
    let offsetSplits = lineSplit(ribbonOffset, impactAreaBuffer);
    offsetSplits.features.pop();
    offsetSplits.features.shift();

    // Get an array of all 2-coordinate line segments that make up the selected features.
    // For each of these segments, create a sector which will indicate the zone of impact
    // for that particular segment.
    let allSegments = lineSegment(fc);
    let sectors = allSegments.features.map(segment => {
        return createSectorForSegment(segment, offsetSplits);
    });

    let zoneOfImpact = union(...sectors);
    updateImpactZone(evt, zoneOfImpact, lengthAll);
}


/**
 * Create a sector to be used in the zone of impact.
 * @param {Feature} segment - a LineString feature
 * @param {FeatureCollection} offsetRibbon - a collection of LineString features
 */
function createSectorForSegment(segment, offsetRibbon) {
    // Get the length of the segment, divide it by 2 and
    // use that value to get the actual midpoint of the segment,
    // lying along the line string itself.
    let segmentLength = length(segment);
    let mid = along(segment, segmentLength/2, { units: "kilometers"});

    // Calculate the segment's bearing and use that to then calculate
    // the bearings for the arc to be created. This will ensure that
    // the arc is always perpendicular to the segment, and that it is
    // facing inland.
    //
    // `minOffset` and `maxOffset` are the two bearings to use for the arc.
    //
    // NOTE: This relies on a CLOCKWISE vulnerability ribbon! If the ribbon
    // were instead to be changed to counter-clockwise, all arcs would be
    // incorrectly drawn TOWARDS THE SEA.
    let brng = calcSegmentBearing(segment.geometry);
    let {minOffset, maxOffset} = calcArcBearingsFromSegmentBearing(brng);

    // Draw the arc to be used for creating the sector. It has a 
    // radius of 500ft (0.1524km) and originates from the midpoint we
    // found above. The `minOffset` and `maxOffset` bearings determine
    // how big the arc is and in what sector of the circle. The number of
    // steps is set at 180. Default is 60 and if you wanted one step per degree,
    // you'd use 360. 180 seems to be a good compromise between accuracy and
    // efficiency.
    // 
    // NOTE: Steps result in the number of vertices in the arc (180 steps !== 180 vertices).
    // Each vertice is used later on when 
    let arc = lineArc(mid.geometry, 0.1524, minOffset, maxOffset, { steps: 180 });

    // Using the arc vertices, draw tracer-rays to determine where and when
    // to clip the arc against intersections with other parts of the vulnerability ribbon
    // so that data from erroneous hexes is not gathered (ie: if a sector crosses an inlet
    // into second piece of land, you strategy would only be affecting the first piece of land
    // and thus should not grab hex data from the second piece). 
    
    // NOTE: Too few steps may result in an unacceptable level of erroneous data being collected,
    // resulting in heavily skewed calculations for the scenario.
    let prunedArc = pruneArc(segment, mid, offsetRibbon, arc.geometry.coordinates);

    // Create the sector out of the coordinates of the original segment and the pruned arc.
    let poly = polygon([
        segment.geometry.coordinates
        .concat(prunedArc)
        .concat([segment.geometry.coordinates[0]])
    ]);

    return toMercator(poly);
}

function pruneArc(segment, segmentMidpoint, offsetRibbon, arcCoords) {
    let lastSegmentCoord = segment.geometry.coordinates[segment.geometry.coordinates.length - 1];
    let firstArcCoord = adjustArcCoord(arcCoords.shift(), lastSegmentCoord, offsetRibbon);

    let firstSegmentCoord = segment.geometry.coordinates[0];
    let lastArcCoord = adjustArcCoord(arcCoords.pop(), firstSegmentCoord, offsetRibbon);

    let innerArcCoords = arcCoords.map(c => {
        return adjustArcCoord(c, segmentMidpoint.geometry.coordinates, offsetRibbon);
    });

    return [firstArcCoord].concat(innerArcCoords).concat([lastArcCoord]);
}

function adjustArcCoord(arcCoord, segmentCoord, offsetRibbon) {
    let tracer = lineString([arcCoord, segmentCoord]);
    
    let intersections = lineIntersect(tracer, offsetRibbon);
    
    if (!intersections || intersections.features.length === 0) return arcCoord;

    let withDistances = intersections.features.reduce((feats, feat) => {
        let d = distance(feat, segmentCoord);
        if (d <= 0.001) return feats;
        feats.push({
            "feature": feat,
            "distance": d
        });
        return feats;
    }, []);
    
    if (withDistances.length === 0) return arcCoord;

    let closestIntersection = withDistances.reduce((closest, next) => {
        if (next.distance < closest.distance) {
            return next;
        } else {
            return closest;
        }
    });

    return closestIntersection.feature.geometry.coordinates;
}

function calcSegmentBearing(point) {
    let start = point.coordinates[0];
    let end = point.coordinates[point.coordinates.length - 1];
    let brng = bearing(start, end);
    return brng;
}

function calcArcBearingsFromSegmentBearing(brng) {
    let midBrng = null,
        minOffset = null,
        maxOffset = null;
    if (brng > 90) {
        midBrng = brng - 270;
    } else {
        midBrng = brng + 90;
    }

    minOffset = midBrng - 10;
    if (minOffset < -180) {
        minOffset = minOffset + 360;
    }

    maxOffset = midBrng + 10;
    if (maxOffset > 180) {
        maxOffset = maxOffset - 360;
    }

    return {
        minOffset: minOffset,
        maxOffset: maxOffset
    };
}

/**
 * Make the first selection on the vulnerability ribbon.
 * 
 * In addition to the feature actually selected, this will
 * add two features to the left and two features to the right
 * for a total of 5 segments selected.
 * 
 * @param {SelectEvent} evt 
 */
function makeInitialSelection(evt) {
    // get selected segment
    let selection = evt.selected[0];
    // flag as selected (for hover stylinz)
    selection.set("selected", true);
    // get selected segment id
    let selectedId = selection.get("OBJECTID");
    // create list of other segment ids to possibly select
    let idsToSelect = [ selectedId - 2, selectedId - 1, selectedId + 1, selectedId + 2 ];
    // set upper/lower id constraints for where to check for subsequent selections.
    evt.target.set("lower_id", idsToSelect[0] - 1);
    evt.target.set("upper_id", idsToSelect[3] + 1);
    // get additional features to actually select
    let toSelect = findFeaturesToAdd(evt, idsToSelect);
    addToSelect(evt, toSelect);

    // add original selection to get complete list of selected items for return
    toSelect.push(selection);
    // sort by id
    toSelect.sort(compareFeaturesById);

    // set selection count to 1
    evt.target.set("num_selected", 1);

    return toSelect;

}

/**
 * Make another selection beyond the first. 
 *
 * In other words, once a selection has been made, you are able to add another
 * 5-segment selection only if it is adjacent (left or right) to the main selection
 *    
 * So if first selection is feature ids [10, 11, 12, 13, 14] then you'll next be
 * able to click a feature from [5, 6, 7, 8, 9] or [15, 16, 17, 18, 19] and have
 * that group be added to the selection. Features outside that range are ignored.
 *
 * Each 5-segment selection that is added to the main selection will update the 
 * constraints to be used in the following clicks
 * 
 * @param {SelectEvent} evt 
 */
function makeAdjacentSelection(evt) {
    // get lower and upper bounds and new ranges
    let lowerId = evt.target.get("lower_id");
    let lowerRange = [lowerId - 4, lowerId - 3, lowerId - 2, lowerId - 1, lowerId];
    let upperId = evt.target.get("upper_id");
    let upperRange = [upperId, upperId + 1, upperId + 2, upperId + 3, upperId + 4];
    // get selected segment
    let selection = evt.selected[0];
    // get selected segment id
    let selectionId = selection.get("OBJECTID");
    
    let idsToSelect = [];
    if (lowerRange.includes(selectionId)) {
        idsToSelect = lowerRange.filter(id => {
            return id !== selectionId;
        });
        evt.target.set("lower_id", lowerRange[0] - 1);
    } else if (upperRange.includes(selectionId)) {
        idsToSelect = upperRange.filter(id => {
            return id !== selectionId;
        });
        evt.target.set("upper_id", upperRange[4] + 1);
    } else {
         evt.target.getFeatures().remove(selection);
         return;
    }
    // flag as selected (for hover stylinz)
    selection.set("selected", true);

    let toSelect = findFeaturesToAdd(evt, idsToSelect);
    addToSelect(evt, toSelect);

    // add original selection to get complete list of selected items for return
    toSelect.push(selection);
    // sort by id
    toSelect.sort(compareFeaturesById);

    // increment num_selected
    let num_selected = evt.target.get("num_selected");
    evt.target.set("num_selected", ++num_selected);

    return toSelect;
}

function findFeaturesToAdd(evt, ids) {
    // get ribbon layer
    let ribbon = evt.target.getMap().getLayers().getArray().filter(layer => {
        return layer.get("name") === "vulnerability_ribbon";
    })[0];
    // filter features to match those we are looking for
    let toSelect = ribbon.getSource().getFeatures().filter(feature => {
        return ids.includes(feature.get("OBJECTID"));
    });
    return toSelect;
}

function addToSelect(evt, featuresToSelect) {
    let collection = evt.target.getFeatures();
    featuresToSelect.forEach(feature => {
        // flag as selected (for hover stylinz)
        feature.set("selected", true);
        // add to selected collection
        collection.push(feature);
    });
}

function updateImpactZone(evt, geojson, lengthAll) {
    let feature = geojsonformat.readFeatureFromObject(geojson);
    evt.target.dispatchEvent({
        "type": "update_impact_zone",
        "shape": feature,
        "length": lengthAll
    });
}

function resetSelectVulnerabilityRibbon(select) {
    // reset styles for selected features
    select.getFeatures().getArray().forEach(f => {
        f.set("selected", false);
    });

    // reset other state
    select.set("num_selected", undefined);
    select.set("lower_id", undefined);
    select.set("upper_id", undefined);

    // deselect all features
    select.getFeatures().clear();
}