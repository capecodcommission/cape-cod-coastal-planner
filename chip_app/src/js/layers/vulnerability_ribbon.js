"use strict";

import VectorSource from "ol/source/Vector";
import VectorLayer from "ol/layer/Vector";
import EsriJSON from "ol/format/EsriJSON";
import Style from "ol/style/Style";
import Fill from "ol/style/Fill";
import Stroke from "ol/style/Stroke";

const esrijsonformat = new EsriJSON();

export function layer(map) {
    let source = new VectorSource();

    let layer = new VectorLayer({
        visible: false,
        source: source,
        style : (feature, resolution) => {
            if (feature.get("selected") === true) {
                return new Style;
            } else {
                return new Style({
                    fill: new Fill({
                        color: "rgba(255,255,255,0.4)"
                    }),
                    stroke: new Stroke({
                        color: "#3399CC",
                        width: 3.25
                    })
                });
            }
        }
    });
    layer.set("name", "vulnerability_ribbon");

    map.on("render_vulnerability_ribbon", ({data}) => {
        onRenderVulnRibbon(data, layer, source);
    });

    return layer;
}


import GeoJSON from "ol/format/GeoJSON";
import lineChunk from "@turf/line-chunk";
import length from "@turf/length";
import {toMercator, toWgs84} from "@turf/projection";
import {featureCollection} from "@turf/helpers";
import lineOffset from "@turf/line-offset";

const geojsonformat = new GeoJSON();

function onRenderVulnRibbon(data, layer, source) {

    // decode esri json to ol features
    let features = esrijsonformat.readFeaturesFromObject(data.response);
    if (features.length === 0) {
        source.clear();
        layer.setVisible(false);
    }

    let offset_geojson = geojsonformat.writeFeatureObject(features[18]);
    offset_geojson = lineOffset(offset_geojson, -1, {units: 'meters'});

    layer.set('offset_geojson', offset_geojson);
    features = [features[18]];
    let nextId = getNextId();
    features = features.reduce((features, feature) => {
        // convert to geojson for analysis
        let geojson = geojsonformat.writeFeatureObject(feature);
        geojson = toWgs84(geojson);

        // chunk lines into 100ft segments
        geojson = chunkBy100(geojson.geometry, nextId);
        geojson = featureCollection(geojson);

        // convert back to feature
        geojson = toMercator(geojson);
        let newFeatures = geojsonformat.readFeaturesFromObject(geojson);

        return features.concat(newFeatures);
    }, []);

    source.addFeatures(features);
    layer.setVisible(true);
}

function getNextId() {
    let nextId = 0;
    return function() { return nextId++; }
}

function chunkBy100(lineFeature, nextId) {
    let len = length(lineFeature, {units: 'kilometers'});
    let chunks = [];    
    if (len >= 10) {
        chunks = lineChunk(lineFeature, 3.048, {units: 'kilometers'});
        chunks = chunks.features.reduce((newChunks, chunk) => {
            let smallerChunks = lineChunk(chunk, 0.3048, {units: "kilometers"});
            return newChunks.concat(smallerChunks.features);
        }, []);
        chunks = chunks.reduce((newChunks, chunk) => {
            let smallerChunks = lineChunk(chunk, 0.03048, {units: "kilometers"});
            smallerChunks.features.forEach(c => {
                if (!isBadSegment(c)) {
                    c.properties.id = nextId();
                    newChunks.push(c);
                }
            });
            return newChunks;
        }, []);
    } else if (len >= 0.3048) {
        chunks = lineChunk(lineFeature, 0.3048, {units: "kilometers"});
        chunks = chunks.features.reduce((newChunks, chunk) => {
            let smallerChunks = lineChunk(chunk, 0.03048, {units: "kilometers"});
            smallerChunks.features.forEach(c => {
                if (!isBadSegment(c)) {
                    c.properties.id = nextId();
                    newChunks.push(c);
                }
            });
            return newChunks;
        })
    } else {
        let newChunks = [];
        chunks = lineChunk(lineFeature, 0.03048, {units: 'kilometers'});
        chunks.features.forEach(c => {
            if (!isBadSegment(c)) {
                c.properties.id = nextId();
                newChunks.push(c);
            }
        });
        return newChunks;
    }
    return chunks;
}

function isBadSegment(feature) {
    if (feature.geometry.coordinates.length === 2) {
        let converted = toMercator(feature);
        return length(converted) === 0;
    }
    return 
}